# 스프링 트랜잭션 추상화


각각의 데이터 접근 기술들은 트랜잭션을 처리하는 방식에 차이가 있다. 예를 들어 JDBC 기술과 JPA 기술은 트랜잭션을 사용하는 코드 자체가 다르다. 

```java
public void accountTransfer(String fromId, String toId, int money) throws
SQLException {
  Connection con = dataSource.getConnection();
  try {
    con.setAutoCommit(false); //트랜잭션 시작
    //비즈니스 로직
    bizLogic(con, fromId, toId, money);
    con.commit(); //성공시 커밋
  } catch (Exception e) {
    con.rollback(); //실패시 롤백
    throw new IllegalStateException(e);
  } finally {
    release(con);
  }
}
```
JDBC 트랜잭션 코드 예시

```java
public static void main(String[] args) {
  //엔티티 매니저 팩토리 생성
  EntityManagerFactory emf = Persistence.createEntityManagerFactory("jpabook");
  EntityManager em = emf.createEntityManager(); //엔티티 매니저 생성
  EntityTransaction tx = em.getTransaction(); //트랜잭션 기능 획득
  
  try {
  tx.begin(); //트랜잭션 시작
    logic(em); //비즈니스 로직
    tx.commit();//트랜잭션 커밋
  } catch (Exception e) {
    tx.rollback(); //트랜잭션 롤백
  } finally {
    em.close(); //엔티티 매니저 종료
  }
  emf.close(); //엔티티 매니저 팩토리 종료
}
```
JPA 트랜잭션 코드 예시


JDBC 기술을 사용하다가 JPA 기술로 변경하게 되면 트랜잭션을 사용하는 코드도 모두 함께 변경해야 한다.
스프링은 이런 문제를 해결하기 위해 트랜잭션 추상화를 제공한다. 트랜잭션을 사용하는 입장에서는 스프링 트랜잭션 추상화를 통해 둘을 동일한 방식으로 사용할 수 있게 되는 것이다.

```java
package org.springframework.transaction;

public interface PlatformTransactionManager extends TransactionManager {
  TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException;
  void commit(TransactionStatus status) throws TransactionException;
  void rollback(TransactionStatus status) throws TransactionException;
}
```
스프링은 PlatformTransactionManager 라는 인터페이스를 통해 트랜잭션을 추상화한다.

트랜잭션은 트랜잭션 시작(획득), 커밋, 롤백으로 단순하게 추상화 할 수 있다.

<img width="461" alt="image" src="https://user-images.githubusercontent.com/65898555/181878798-af61e6c2-6add-490f-8d1b-e74ae36aac3e.png">


스프링은 트랜잭션을 추상화해서 제공할 뿐만 아니라, 실무에서 주로 사용하는 데이터 접근 기술에 대한 트랜잭션 매니저의 구현체도 제공한다. 

스프링 부트는 어떤 데이터 접근 기술을 사용하는지를 자동으로 인식해서 적절한 트랜잭션 매니저를 선택해서 스프링 빈으로 등록해주기 때문에 트랜잭션 매니저를 선택하고 등락하는 과정도 생략할
수 있다. 예를 들어서 JdbcTemplate , MyBatis를 사용하면 DataSourceTransactionManager(JdbcTransactionManager)를 스프링 빈으로 등록하고, JPA를 사용하면 JpaTransactionManager 를 스프링 빈으로 등록해준다.

스프링 5.3부터는 JDBC 트랜잭션을 관리할 때 DataSourceTransactionManager를 상속받아서 약간의 기능을 확장한 JdbcTransactionManager를 제공한다. 둘의 기능 차이는 크지 않으므로 같은 것으로
이해하면 된다.

<img width="464" alt="image" src="https://user-images.githubusercontent.com/65898555/181878854-995f87cc-a5be-494c-b6fd-1fc7a3172639.png">

@Transactional 애노테이션이 특정 클래스나 메서드에 하나라도 있으면 있으면 트랜잭션 AOP는 프록시를 만들어서 스프링 컨테이너에 등록한다. 그리고 실제 basicService 객체 대신에 프록시인 basicService$$CGLIB 를 스프링 빈에 등록한다. 그리고 프록시는 내부에 실제 basicService를 참조하게 된다. 여기서 핵심은 실제 객체 대신에 프록시가 스프링 컨테이너에 등록되었다는 점이다.

클라이언트인 txBasicTest는 스프링 컨테이너에 @Autowired BasicService basicService로 의존관계 주입을 요청한다. 스프링 컨테이너에는 실제 객체 대신에 프록시가 스프링 빈으로 등록되어 있기때문에 프록시를 주입한다. 프록시는 BasicService를 상속해서 만들어지기 때문에 다형성을 활용할 수 있다. 따라서 BasicService 대신에 프록시인 BasicService$$CGLIB를 주입할 수 있다.

<img width="461" alt="image" src="https://user-images.githubusercontent.com/65898555/181878880-afe168b8-af87-4fd0-b1be-59cb8a020904.png">

클라이언트가 주입 받은 basicService$$CGLIB는 트랜잭션을 적용하는 프록시이다.











