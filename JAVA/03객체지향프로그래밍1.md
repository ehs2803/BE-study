# JVM의 메모리 구조

응용프로그램이 실행되면, JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고 JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.

그 중 method area, call stack, heap이 중요하다.

1. 메서드 영역(method area)<br>
프로그램 실행 중 어떤 클래스가 사용되면 JVM은 해당 클래스의 클래스파일을 읽어서 분석하여 클래스에 대한 정보(클래스 데이터)를 이곳에 저장한다. 이때, 그 클래스의 클래스변수도 이 영역에 함께 생성한다.

2. 힙(heap)<br>
인스턴스가 생성되는 공간으로 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다. 즉 인스턴스 변수들이 생성되는 공간이다.

3. 호출스택(call stack or execution stack)<br>
호출스택은 메서드의 작업에 필요한 메모리 공간을 제공한다. 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당되며, 이 메모리는 메서드가 작업을 수행하는 동안 지역변수(매개변수 포함)
들과 연산의 중간결과 등을 저장하는데 사용된다. 그리고 메서드가 작업을 마치면 할당되었던 메모리공간은 반환되어 비워진다.
각 메서드를 위한 메모리상의 작업공간은 서로 구별되며, 첫번째로 호출된 메서드를 위한 작업공간이 호출스택의 맨 밑에 마련되고, 첫번쩨 메서드 수행 중에 다른 메서드를 호출하면, 첫번째 메서드의 
바로 위에 두번째로 호출된 메서드를 위한 공간이 마련된다.

- 메서드가 호출되면 수행에 필요한 만큼의 메모리를 스택에 할당받는다.
- 메서드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거
- 호출스택의 제일 위에 있는 메서드가 현재 실행 중인 메서드
- 아래에 있는 메서드가 바로 위에 메서드를 호출한 메서드이다.

# 클래스와 객체

1. 변수 : 하나의 데이터를 저장할 수 있는 공간
2. 배열 : 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
3. 구조체 : 서로 관련된 여러 데이트를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
4. 클래스 : 데이터와 함수의 결합(구조체+함수)


클래스 : 객체를 정의해 놓은 것으로 객체를 생성하는데 사용된다.

객체 : 실제로 존재하는 것, 사물 또는 개념으로 객체가 가지고 있는 기능과 속성에 따라 다르다.

# 객체와 인스턴스

클래스로부터 객체를 만드는 과정을 클래스의 인스턴화라고 한다.
어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 한다.

# 객체의 구성요소

속성(property) : 멤버변수, 특성, 필드, 상태

기능(function) : 메서드, 함수, 행위

# 인스턴스의 생성과 사용

```java
클래스명 변수명;
변수명 = new 클래스명();

Tv t;
t = new Tv();

class Tv { 
     // Tv의 속성(멤버변수) 
     String color;           	// 색상 
     boolean power;         	// 전원상태(on/off) 
     int channel;           	// 채널 

     // Tv의 기능(메서드) 
     void power()   { power = !power; }  // TV를 켜거나 끄는 기능을 하는 메서드  
     void channelUp()   {  ++channel; }  // TV의 채널을 높이는 기능을 하는 메서드 
     void channelDown() { --channel; }   // TV의 채널을 낮추는 기능을 하는 메서드  
}

class TvTest { 
      public static void main(String args[]) { 
            Tv t;                  // Tv인스턴스를 참조하기 위한 변수 t를 선언       
            t = new Tv();          // Tv인스턴스를 생성한다. 
            t.channel = 7;         // Tv인스턴스의 멤버변수 channel의 값을 7로 한다. 
            t.channelDown();       // Tv인스턴스의 메서드 channelDown()을 호출한다. 
            System.out.println("현재 채널은 " + t.channel + " 입니다."); 
      } 
}
```
인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타이은 인스턴스의 타입과 일치해야 한다.

# 객체 배열


```java
class TvTest4 {
	public static void main(String args[]) {
		Tv[] tvArr = new Tv[3]; // 길이가 3인 Tv객체 배열

		// Tv객체를 생성해서 Tv객체 배열의 각 요소에 저장
		for(int i=0; i < tvArr.length;i++) {
			tvArr[i] = new Tv();
			tvArr[i].channel = i+10; // tvArr[i]의 channel에 i+10을 저장
		}

		for(int i=0; i < tvArr.length;i++) {
			tvArr[i].channelUp();  // tvArr[i]의 메서드를 호출. 채널이 1증가
			System.out.printf("tvArr[%d].channel=%d%n",i,tvArr[i].channel);
		}
	} // main의 끝
}

class Tv { 
     // Tv의 속성(멤버변수) 
     String color;           // 색상 
     boolean power;          // 전원상태(on/off) 
     int channel;          	 // 채널 

     // Tv의 기능(메서드) 
     void power()   { power = !power; }  // TV를 켜거나 끄는 기능을 하는 메서드 
     void channelUp()   {  ++channel; }  // TV의 채널을 높이는 기능을 하는 메서드 
     void channelDown() {  --channel; }  // TV의 채널을 낮추는 기능을 하는 메서드  
}
```
객체 배열안에 객체가 저장되는 것이 아니라 객체의 주소가 저장된다. 
객체 배열은 참조변수들을 하나로 묶은 참조 변수 배열이다.

# 변수와 메서드

### 선언위치에 따른 변수의 종류

|변수의 종류|선언위치|생성시기|
|-----|-----|-----|
|클래스변수|클래스 영역|클래스가 메모리에 올라갈 때|
|인스턴스 변수|클래스 영역|인스턴스가 생성될때|
|지역변수|클래스 영역 이외의 영역(메서드, 생성자, 초기화 블럭 내부)|변수 선언문이 수행될때|

1. 인스턴스 변수<br>
클래스 영역에 선언되며, 클래스의 인스턴스를 생성할 때 만들어진다. 이 값을 읽어오거나 저장하기 위해 먼저 인스턴스를 생성해야 한다.
인스턴스는 독립적인 공간을 가지고 있어 서로 다른 값을 가질 수 있다.(인스턴스 마다)

2. 클래스 변수<br>
클래스 변수 선언 방법은 인스턴스 변수 앞에 static을 붙이면 된다. 인스턴스마다 독립적인 저장공간을 가지지 않는다. 모든 인스턴스가 공통된 저장공간(변수)을 공유한다.
클래스 변수는 인스턴스를 생성하지 않고도 언제라도 사용가능하다. ' 클래스이름.클래스변수 ' 로 접근이 가능하다.
클래스가 메모리에 로딩될때 생성되어 프로그램이 종료될 때 까지 유지되며 public을 앞에 붙이면 같은 프로그램 내에서 어디서나 접근할 수 있는 전역변수의 성격을 갖는다.

3. 지역변수<br>
메서드 내에 선언되에 메서드 내에서만 사용가능하다. 메서드가 종료되면 소멸되어 사용할 수 없다.

### 메서드

메서드는 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것이다.

메서드를 사용하는 이유는 높은 재사용성, 중복된 코드 제거, 프로그램의 구조화가 있다.

```java
반환타입 메서드이름 ( 타입변수명, 타입 변수명, ...)
{
   메서드 호출시 수행될 코드
}

int add(int a, int b){
    return a+b;
}

int result = add(1,2); // method 호출
```
메서드를 호출할 때 괄호 안에 지정해준 값들을 인자(argument) 또는 인수라고 한다. 
인자는 메서드가 호출되면서 매개변수에 대입된다. 인자의 타입은 매개변수의 타입과 일치하거나 자동 형변환이 가능한 것이어야 한다.


### 기본형 매개변수와 참조형 매개변수

기본형 매개변수 : 변수의 값을 읽기만 할 수 있음.

참조형 매개변수 : 변수의 값을 읽고 변경할 수 있음.

### 참조형 반환타입

매개변수뿐만 아니라 반환타입도 참조형이 될 수 있다.

반환타입이 참조형이라는 것은 메서드가 객체의 주소를 반환한다는 것을 의미한다.

### 클래스 메서드(static 메서드)와 인스턴스 메서드

메서드 앞에 static을 붙이면 클래스메서드이고 아니면 인스턴스 메서드이다.

클래스 메서드는 객체를 생성하지 않고 '클래스이름.메서드이름(매개변수)' 형식으로 호출이 가능하다. 
반면 인스턴스 메서드는 반드시 객체를 생성 후 호출해야 한다.

인스턴스 메서드는 인스턴스 변수와 관련된 작업을 하는, 즉 메서드의 작업을 수행하는데 인스턴스 변수를 필요로 하는 메서드이다.

인스턴스와 관계없는(인스턴스 변수나 메서드를 사용x) 메서드를 클래스 메서드(static 메서드)라고 한다.
물론 인스턴스 변수를 사용하지 않는다고 반드시 클래스 메서드로 정의해야하는 것은 아니다.

1. 클래스 설계시, 멤버변수 중 모든 인스턴스 공통으로 사용하는 것에 static 붙이기
2. 클래스 변수(static변수)는 인스턴스를 생성하지 않아도 사용 가능.
3. 클래스 메서드(static 메서드)는 인스턴스 변수 사용 불가
4. 메서드 내에서 인스턴스 변수를 사용하지 않는다면 static 붙이는거 고려.

같은 클래스에서 클래스 메서드는 인스턴스 메서드, 인스턴스 변수를 호출할 수 없다. 다만 인스턴스 메서드는 클래스 메서드, 클래스 변수를 호출할 수 있다.

인스턴멤버간의 호출에는 아무런 문제가 없다. 하나의 인스턴스멤버가 존재한다는 것은 인스턴스가 이미 생성되었다는 것을 의미하며, 즉 다른 인스턴스 멤버들도 모두 존재하기 때문.

# 오버로딩(overloading)

메서드도 변수와 마찬가지로 같은 클래스 내에서 서로 구별될 수 있어야 하므로 각기 다른 이름을 가져야 한다. 그러나 한 클래스 내에 이미 사용하려는 이름과 같은 이름을 가진 메서드가 있어
도 매개변수의 개수 또는 타입이 다르면, 같은 이름을 사용해 메서드를 정의할 수 있다.

이처럼, 한 클래스 내에 같은 이름의 메서드를 여러개 정의하는 것을 메서드 오버로딩 또는 오버로딩이라고 한다.

오버로딩의 조건은 다음과 같다.
1. 메서드 이름이 같다
2. 매개변수 개수 또는 타입이 달라야 한다.

반환 타입은 오버로딩을 구현하는데 아무런 영향을 주지 못한다.

```java
int add(int a, int b)

long add(int a, int b)
```
위 경우는 반환타입만 다르기 때문에 컴파일 시 오류가 난다.

```java
long add(int a, long b)

long add(long a, int b)
```
위 경우는 서로 순서가 다르기 때문에 오버로딩으로 간주한다.

오버로딩 장점은 메서드가 변수처럼 단지 이름만으로 구별된다면, 한 클래스내에서 모두 메서드들은 이름이 달라야한다.
메서드를 사용하는 입장에서 비슷한 기능을 하는 경우 모든 메서드의 이름을 구분해 기억해야 하는 어려움이 있다.
하지만 오버로딩을 통해 여러 메서드들이 하나의 이름으로 정의될 수 있다.

# 가변인자와 오버로딩

기존의 메서드의 매개변수 개수가 고정적이었다.

JDK1.5부터 동적으로 지정이 가능하다. 이 기능을 가변인자(variable arguments)라고 한다.

```java
public printStream printf(String format, Object... args) { }
```

가변인자 외에 매개변수가 있다면 가변인자를 매개변수 중에서 제일 마지막에 선언해야 한다.

매개변수 타입을 배열로 하면, 반드시 인자를 지정해 줘야 한다. 생략이 불가능하다. 그래서 null이나 길이가 0인 배열을 지정해야하는 불편함이 있다.

```java
class VarArgsEx {
	public static void main(String[] args) {
		String[] strArr = { "100", "200", "300" };
		
		System.out.println(concatenate("", "100", "200", "300"));
		System.out.println(concatenate("-", strArr));
		System.out.println(concatenate(",", new String[]{"1", "2", "3"})); //concatenate(",",{"1", "2", "3"})불가
		System.out.println("["+concatenate(",", new String[0])+"]");
		System.out.println("["+concatenate(",")+"]");
	}

	static String concatenate(String delim, String... args) {
		String result = "";

		for(String str : args) {
			result += str + delim;
		}
		
		return result;
	}

/*
	static String concatenate(String... args) {
		return concatenate("",args);
	}
*/
} // class
```
위 코드에서 주석부분을 풀면 오류가 발생한다.
오버로딩된 메서드가 구분되지 않아서 발생하는 것이다. 가변인자를 선언한 메서드를 오버로딩하면, 메서드 호출시 이와 같이 구별되지 못하는 경우가 발생하기 쉬워 중의해야 한다.
따라서 가능하면 가변인자를 사용한 메서드는 오버로딩하지 않는 것이 좋다.


